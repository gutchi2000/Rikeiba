<script>
// ==== 読み込むJSON（index.htmlと同じ階層） ====
const FILES = [
  "もみじS.json",
  "アイビーS.json",
  "ブラジルC.json",
  "富士S.json",
  "新潟牝馬S.json",
  "甲斐路S.json",
  "秋華賞.json",
];

let RAW = null;          // 結合後データ
let DAYS = [];           // [{date, races:Array}]
let CURRENT_DATE = "";   // 選択中の日付
let VENUES = [];         // 場名候補

// ==== Utils ====
const esc = s => String(s||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
const getGrade = name => {
  const s = String(name||"").toUpperCase();
  if (/(^|\W)(G1|Ｇ1|GI|ＧＩ)($|\W)/.test(s)) return "G1";
  if (/(^|\W)(G2|Ｇ2|GII|ＧＩＩ)($|\W)/.test(s)) return "G2";
  if (/(^|\W)(G3|Ｇ3|GIII|ＧＩＩＩ)($|\W)/.test(s)) return "G3";
  if (/(^|\W)L($|\W)|リステッド/.test(name||"")) return "L";
  if (/オープン|(^|\W)OP($|\W)|OPEN/i.test(name||"")) return "OP";
  return "None"; // 3勝/2勝などはここに落ちる
};
const parseSurf  = track => String(track||"").includes("ダ") ? "ダ" : (String(track||"").includes("芝") ? "芝" : "");
const parseVenue = track => (String(track||"").trim().split(/\s|　/)[0] || "");
const normDate   = v => {
  // 文字列日付はそのまま使い、Dateにした時だけISO化
  if (v instanceof Date) return new Date(v.getFullYear(), v.getMonth(), v.getDate()).toISOString().slice(0,10);
  return String(v);
};

// ==== 複数JSONをロードして、同日を結合 ====
async function load(){
  const results = await Promise.all(
    FILES.map(f =>
      fetch("./" + encodeURI(f) + "?_=" + Date.now(), { cache:"no-store" })
        .then(r => r.ok ? r.json() : null)
        .catch(() => null)
    )
  );

  // まず days[] をすべて拾う
  const daysRaw = [];
  for (const d of results) {
    if (!d) continue;
    if (Array.isArray(d?.days)) {
      daysRaw.push(...d.days);
    } else if (d?.date && Array.isArray(d?.races)) {
      daysRaw.push({ date: d.date, races: d.races });
    }
  }

  // <<< ここが肝：dateごとにレースを結合・重複排除 >>>
  const byDate = new Map(); // date -> Array<race>
  for (const d of daysRaw) {
    const ymd = normDate(d.date);
    if (!byDate.has(ymd)) byDate.set(ymd, []);
    const bucket = byDate.get(ymd);
    for (const r of (d.races||[])) bucket.push(r);
  }

  // 任意：race_id があるものは重複排除（同じ日付で同じIDが複数ファイルにある可能性に備える）
  const dedup = (races) => {
    const seen = new Set();
    const out = [];
    for (const r of races) {
      const key = r.race_id ? String(r.race_id) : (r.race_name ? `N:${r.race_name}` : JSON.stringify(r));
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(r);
    }
    return out;
  };

  DAYS = Array.from(byDate.entries())
    .map(([date, races]) => ({ date, races: dedup(races) }))
    .sort((a,b)=> String(b.date).localeCompare(String(a.date))); // 新しい日付が先

  RAW = { days: DAYS };
  CURRENT_DATE = DAYS[0]?.date || "";
  buildDateUI();
  rebuildVenueList();
  render();
}

// ==== 日付UI ====
function buildDateUI(){
  const tabs = document.getElementById("dateTabs");
  const sel  = document.getElementById("dateSelect");
  tabs.innerHTML = "";
  sel.innerHTML = "";

  DAYS.forEach((d) => {
    const b = document.createElement("button");
    b.className = "tab" + (d.date===CURRENT_DATE ? " on": "");
    b.textContent = d.date;
    b.onclick = ()=>{ CURRENT_DATE = d.date; syncDateSelect(); rebuildVenueList(); render(); };
    tabs.appendChild(b);

    const opt = document.createElement("option");
    opt.value = d.date; opt.textContent = d.date;
    if (d.date===CURRENT_DATE) opt.selected = true;
    sel.appendChild(opt);
  });

  document.getElementById("dateSelect").onchange = (e)=>{
    CURRENT_DATE = e.target.value;
    syncTabs();
    rebuildVenueList();
    render();
  };
}

function syncTabs(){
  document.querySelectorAll(".tab").forEach(el=>{
    el.classList.toggle("on", el.textContent===CURRENT_DATE);
  });
}
function syncDateSelect(){
  const sel = document.getElementById("dateSelect");
  [...sel.options].forEach(o=> o.selected = (o.value===CURRENT_DATE));
}

// ==== 場名のプルダウン ====
function rebuildVenueList(){
  const today = DAYS.find(d=> d.date===CURRENT_DATE);
  const venues = new Set();
  (today?.races||[]).forEach(r=> venues.add(parseVenue(r.track)));
  const arr = [...venues].filter(Boolean).sort((a,b)=>a.localeCompare(b));
  VENUES = arr;
  const vsel = document.getElementById("venueSelect");
  vsel.innerHTML = "<option value=''>すべて</option>" + arr.map(v=>`<option>${esc(v)}</option>`).join("");
}

// ==== フィルタ状態 ====
const state = { q:"", grades:new Set(), surfs:new Set(), minD:"", maxD:"", venue:"", sort:"time" };

function hookFilters(){
  document.getElementById("q").oninput = e=>{ state.q = e.target.value.trim(); render(); };

  // グレード：'指定なし' はフィルタ解除として扱う
  document.getElementById("gradeChips").addEventListener("click", e=>{
    const chip = e.target.closest(".chip"); if(!chip) return;
    const g = chip.dataset.grade;
    if (g === "None") {
      // フィルタ解除
      state.grades.clear();
      document.querySelectorAll('#gradeChips .chip').forEach(c=>c.classList.remove('on'));
      // '指定なし'を見た目でONにしない場合は以下を外す
      // chip.classList.add('on');
      render();
      return;
    }
    // 通常トグル
    if (chip.classList.toggle("on")) state.grades.add(g);
    else state.grades.delete(g);
    // '指定なし'がONになっていたら外す
    document.querySelector('#gradeChips .chip[data-grade="None"]')?.classList.remove('on');
    render();
  });

  document.getElementById("surfChips").addEventListener("click", e=>{
    const chip = e.target.closest(".chip"); if(!chip) return;
    const s = chip.dataset.surf;
    if (chip.classList.toggle("on")) state.surfs.add(s);
    else state.surfs.delete(s);
    render();
  });

  document.getElementById("minD").oninput = e=>{ state.minD = e.target.value; render(); };
  document.getElementById("maxD").oninput = e=>{ state.maxD = e.target.value; render(); };

  document.getElementById("venueSelect").onchange = e=>{ state.venue = e.target.value; render(); };
  document.getElementById("sortSelect").onchange  = e=>{ state.sort  = e.target.value; render(); };

  document.getElementById("clearBtn").onclick = ()=>{
    state.q=""; state.grades.clear(); state.surfs.clear(); state.minD=""; state.maxD=""; state.venue=""; state.sort="time";
    document.getElementById("q").value="";
    document.querySelectorAll(".chip.on").forEach(x=>x.classList.remove("on"));
    document.getElementById("minD").value=""; document.getElementById("maxD").value="";
    document.getElementById("venueSelect").value="";
    document.getElementById("sortSelect").value="time";
    render();
  };

  document.getElementById("refreshBtn").onclick = ()=> load();
}

// ==== 描画 ====
function render(){
  const container = document.getElementById("raceList");
  const empty = document.getElementById("emptyMsg");
  container.innerHTML = "";

  const day = DAYS.find(d=> d.date===CURRENT_DATE);
  if (!day || !Array.isArray(day.races)) { empty.style.display = "block"; return; }

  let races = day.races.map(r=>{
    const race_name = r.race_name || r.race_id || "";
    const grade = getGrade(race_name);
    const surf = parseSurf(r.track);
    const venue = parseVenue(r.track);
    const distance = (typeof r.distance === "number") ? r.distance : Number(r.dist||NaN);
    return {...r, __race_name: race_name, __grade: grade, __surf: surf, __venue: venue, __distance: distance};
  });

  const q = state.q.toLowerCase();
  if (q) races = races.filter(r =>
    r.__race_name.toLowerCase().includes(q) ||
    (r.track||"").toLowerCase().includes(q) ||
    (r.__venue||"").toLowerCase().includes(q) ||
    (r.picks||[]).some(p => String(p.horse||"").toLowerCase().includes(q))
  );

  if (state.grades.size) races = races.filter(r => state.grades.has(r.__grade));
  if (state.surfs.size)  races = races.filter(r => state.surfs.has(r.__surf));
  if (state.venue)       races = races.filter(r => r.__venue === state.venue);

  const minD = Number(state.minD||0), maxD = Number(state.maxD||0);
  if (minD || maxD) {
    races = races.filter(r => {
      const d = Number(r.__distance||0);
      const okMin = minD ? (d >= minD) : true;
      const okMax = maxD ? (d <= maxD) : true;
      return okMin && okMax;
    });
  }

  if (state.sort==="grade"){
    const ord = {G1:1,G2:2,G3:3,L:4,OP:5,None:6};
    races.sort((a,b)=> (ord[a.__grade]||9)-(ord[b.__grade]||9) || String(a.__race_name).localeCompare(String(b.__race_name)));
  } else if (state.sort==="distance"){
    races.sort((a,b)=> (a.__distance||0) - (b.__distance||0));
  } else if (state.sort==="venue"){
    races.sort((a,b)=> String(a.__venue).localeCompare(String(b.__venue)) || (a.__distance||0)-(b.__distance||0));
  }

  if (!races.length){ empty.style.display="block"; return; }
  empty.style.display="none";

  races.forEach(r=>{
    const title = (r.__race_name || r.race_id || "").trim();
    const metaParts = [ r.__venue || "", r.__surf || (String(r.track).includes("ダ")?"ダ":""), r.__distance? `${r.__distance}m`:"", r.going||"" ].filter(Boolean);
    const grade = r.__grade==="None" ? "" : r.__grade;

    const card = document.createElement("div");
    card.className = "race";
    card.innerHTML = `
      <div class="race-head">
        <div>
          <div class="title">${esc(title)}</div>
          <div class="meta">${esc(metaParts.join(" / "))}</div>
        </div>
        <div class="chips2">
          ${grade? `<span class="tag">${esc(grade)}</span>`:``}
          ${r.race_id? `<span class="tag">ID: ${esc(r.race_id)}</span>`:``}
        </div>
      </div>
      <div class="picks">
        ${(r.picks||[]).map(p=>`
          <div class="pick">
            <span class="mark">${esc(p.mark||"")}</span>
            <span class="horse">${esc(p.horse||"")}</span>
          </div>
        `).join("")}
      </div>
    `;
    container.appendChild(card);
  });
}

// 起動
hookFilters();
load();
</script>
